      program makesuperatom
*
* v5: adds spectral terms in the superatom id (sid). 
*     adds minE (minimum energy below which no levels are merged) as an input parameter
*     generalized to other atoms than iron. ThiM 11/09-2019
* v4: adds a strength index at the end of each bb line of the reformatted full atom. BPz 06/05-2016
* v3: does not group lowest levels, increase grouping for FeII.  BPz 02/05-2016
* v2: first group according to term designation. BPz 20/04-2016
*
*  B. Plez 21/03-2016 -14/04-2016
* make a super-atom from a full atom.
* levels and transitions are merged into superlevels and supertransitions
* a copy of the original atom with level - supelevel correspondances is also created
*
      implicit none
      integer maxlev,maxline,maxslev,maxsline,m,mm,idum,maxk,k,nd,kk,jj
      integer iscan, version, ios
      parameter (maxlev=2000,maxline=250000,maxslev=1000,
     &           maxsline=250000,version=5)
      character*256 filein,fileout,oneline,head(200),fileinreformatted
      character*256 fileout2
      character*1 onechar,iup(maxline),ilow(maxline)
      character*10 elt, sym, date
      character id(maxlev)*1000,sid(maxslev)*1000
      character st(maxlev)*100,tsst(maxlev)*100,sst(maxslev)*100
      character type*5,aa*5
      integer ion(maxlev),sion(maxslev),n(maxlev),ns(maxlev),
     &        tsion(maxslev),tns(maxlev),tnslev,ttsion,nswap
      integer i,j,nline,nlev,ncont,nfix,nslev,nsline,nscont,nsfix
      integer l,ii(3),up(maxline),low(maxline),nq(maxline),iw(maxline),
     &        ups(maxline),lows(maxline),nread,nt,ntr,nn(maxlev,maxlev)
      integer kr(maxline),snq(maxslev,maxslev),nwr,nhead
      integer ntemp,sl(maxlev),nwav,shift
      real f(maxline),qmax(maxline),q0(maxline),ga(maxline),
     &     gs(maxline),tunedgv,alogc6,dum,tt(20),tr(20),gv(maxline)
      real*8 fact1,fact2,sum1,sum2,scf(maxslev),sf(maxslev,maxslev),
     &       sgv(maxslev,maxslev),sga(maxslev,maxslev),
     &       sgs(maxslev,maxslev)
      real sqmax(maxslev,maxslev),strength,
     &     sq0(maxslev,maxslev),
     &     sigmacross,velexp,tem(20,maxlev,maxlev),
     &     gam6,scol(20,maxslev,maxslev),
     &     col(20,maxlev,maxlev),coll(20)

      integer upc(maxlev),lowc(maxlev),nc(maxlev),maxcpoint
      integer supc(maxslev),slowc(maxslev),snc(maxslev)
      parameter (maxcpoint=5000)
      real*8 cf(maxlev),cx(maxcpoint,maxlev),scx(maxcpoint,maxslev),
     &     scxtemp(maxcpoint)
      real*8 lambdaminc(maxlev),cl(maxcpoint,maxlev),lambda0,
     &       scl(maxcpoint,maxslev),scltemp(maxcpoint),
     &       slambdaminc(maxslev)
      
      real*8 DE,minE,maxE,e(maxlev),se(maxslev),temp,kbcm,sq(maxslev),
     &       lam(maxline),lamv(maxline),slam(maxslev,maxslev),
     &       slamv(maxslev,maxslev),eion(2),sqq(20,maxslev),
     &       tsq(maxslev),tse(maxslev),ttse,ttsq
      character*100 ttsst
      real g(maxlev),sg(maxslev),gsum,t,boltz,tsg(maxslev),ttsg
      logical first1,first2,first,down,first3,extrapo,first4,
     &        exist(maxlev,maxlev),debug,used(maxlev)
* Boltzmann constant in cm-1.K-1
      data kbcm /0.69503457d0/
      boltz=1.3806e-16


      write(6,10) 'Full atom input file (MULTI format)'
10    format(a)
      read(5,10) filein
      open(10,file=filein,status='old')

      write(6,10) 'Super atom output file '
      read(5,10) fileout
      open(20,file=fileout)

* big input atom, with levels renamed to allow redistribution from superatom
*      write(fileinreformatted,13) trim(filein),'_superlev_',
*     &      trim(fileout)
*13    format(3a)
*     name output files
      iscan=scan(fileout,'.',back=.true.)
      write(fileinreformatted,'(2A)')
     &'atom2.',fileout(iscan+1:len(trim(fileout)))
      write(fileout2,'(3A)')
     &'atom2.',fileout(iscan+1:len(trim(fileout))),'_dropped_lines'
      open(30,file=fileinreformatted)
* lines within superlevels. Might be good to check that no strong line has been dropped
      open(40,file=fileout2)
*      open(40,file='DROPPED_lines.dat')
      write(6,10) 'Do not merge levels below this energy (cm-1)'
      read(5,*) minE
      write(6,10) 'Minimum energy range for super-levels (cm-1)'
      read(5,*) DE
      write(6,10) 'Typical temperature for the use of the superatom'
      write(6,10) '  This T will be used to compute partition functions'
      write(6,10) '  within superlevels, and to estimate gamma6'
      read(5,*) temp
      t=sngl(temp)

* keep track of number of lines already read from input file
      nread=0
      read(10,10) oneline
      nread=nread+1
* read element
      iscan=scan(oneline,' ')
      elt=oneline(1:iscan)  
* read element + ionization
      sym=oneline(1:10)   

      call date_and_time(DATE=date)
      write(20,'(2A,I1,2A)') trim(sym),
     &'       generated by makesuperatom_v',version,' ',date
      write(30,'(2A,I1,2A)') trim(sym),
     &'       generated by makesuperatom_v',version,' ',date 
      write(20,11) trim(filein)
      write(20,112) minE
      write(20,17) DE,10.*DE    
      write(30,111) trim(fileout)
      write(20,'(2A,F8.1,A)')'* Temperature used to compute partition',
     &' functions in superlevels and to estimate gamma6: ',t,' K'
      write(20,'(2A)') '* ',trim(oneline)
      write(30,'(2A)') '* ',trim(oneline)
11    format('* Super-atom generated from ',a)
112   format('* Energy levels first grouped according to term ',
     &        'designation, except levels lower than ',f8.3,' cm-1')
*     &        'term designation, except 13 lowest FeI.')
17    format('* Then binned within ',f7.1,' cm-1',
     &    ' increasing to ',f7.1,' for the next ion')
*     &    ' increasing to ',f7.1,' at higher energy for FeII')
111   format('* atom reformatted to same level id than the',
     &      ' superatom ',a)

      read(10,10) oneline
      nread=nread+1
      read (oneline,10) onechar
      do while (onechar.eq.'*') 
        write(20,10) trim(oneline)
        write(30,10) trim(oneline)
        read(10,10) oneline
        nread=nread+1
        read(oneline,10) onechar
      enddo
* first we have the '  XXXX   55.845' line
      write(20,10) trim(oneline)
      write(30,10) trim(oneline)
* then '*        NK        NLIN          NCNT        NFIX
      read(10,10) oneline
      nread=nread+1
      write(20,10) trim(oneline)
      write(30,10) trim(oneline)
* now the real data
      read(10,*) nlev,nline,ncont,nfix
      print*,nlev,nline,ncont,nfix
      nread=nread+1
      if (nlev.gt.maxlev) then
        stop 'increase maxlev dimension'
      endif
      if (nline.gt.maxline) then
        stop 'increase maxline dimension'
      endif
* levels header
      nhead=1
      read(10,10) head(nhead)
      nread=nread+1

      first1=.true.
      first2=.true.
      do i=1,nlev
        read(10,*) e(i),g(i),id(i),ion(i),n(i)
        if (first1.and.ion(i).eq.2) then
          first1=.false.
          eion(1)=e(i)
        else if (first2.and.ion(i).eq.3) then
          first2=.false.
          eion(2)=e(i)
        endif
* extract spectral term from id
      iscan=scan(trim(id(i)),set=' ',back=.true.)
      st(i)=trim(id(i)(iscan:len(id(i))))       
      enddo
* check energies (energy difference from one level to the next should be at least 0.001 for multi reading
      do i=2,nlev
        if (int(e(i)*1000.).le.int(e(i-1)*1000.)) then
          print*,'problem with energies '
          print*,i-1, e(i-1),i,e(i),e(i)-e(i-1)
        endif
      enddo
      nread=nread+nlev
      print*,'ionization energies, ',trim(elt),' I : ',eion(1),' ',
     &  trim(elt),' II : ',eion(2)
* Super-levels energy bins. First superlevel starts at fundamental
* Superlevels have an id that is only a number 
*
* First group levels  into temporary superlevels according to designation 
      used=.false.
      j=1
      do l=1,nlev
        if (.not.used(l)) then
          used(l)=.true.
          tsion(j)=ion(l)
          tns(l)=j
          tnslev=j
          do i=l+1,nlev
* don't mix ionization stages
* don't merge first 13 levels (E< 2eV).
            if (.not.used(i).and.ion(i).eq.tsion(j).and.
     &          id(i).eq.id(l).and.e(i).gt.minE) then
*     &          id(i).eq.id(l).and.i.gt.13) then
* group
              used(i)=.true.
              tns(i)=j
            endif
          enddo
* next superlevel
          j=j+1
        endif
      enddo
      print*,'combined term levels resulted in ',
     &      tnslev,' superlevels'
* compute temporary superlevel partition function, multiplicity and mean energy
      do j=1,tnslev
        tsq(j)=0.0
        tsg(j)=0.0
        tse(j)=0.0
        tsst(j)=''
        do i=1,nlev
          if (tns(i).eq.j) then
            tsq(j)=tsq(j)+g(i)*exp(-e(i)/kbcm/temp)
            tsg(j)=tsg(j)+g(i)
            tse(j)=tse(j)+e(i)*g(i)*exp(-e(i)/kbcm/temp)
*           combine spectral terms for temporary super spectral term 
            tsst(j)=trim(tsst(j))//' '//st(i)
          endif
        enddo
        tse(j)=tse(j)/tsq(j)
      enddo

* bubble sort the temporary superlevels in increasing energy order
  110 continue
      nswap=0
      do j=2,tnslev
        if(tse(j-1).gt.tse(j)) then
          ttse=tse(j-1)
          ttsq=tsq(j-1)
          ttsg=tsg(j-1)
          ttsst=tsst(j-1)
          ttsion=tsion(j-1)
          tse(j-1)=tse(j)
          tsq(j-1)=tsq(j)
          tsg(j-1)=tsg(j)
          tsst(j-1)=tsst(j)
          tsion(j-1)=tsion(j)
          tse(j)=ttse
          tsq(j)=ttsq
          tsg(j)=ttsg
          tsst(j)=ttsst
          tsion(j)=ttsion
          do i=1,nlev
            if (tns(i).eq.j-1) then
              tns(i)=j
            else if (tns(i).eq.j) then
              tns(i)=j-1
            endif
          enddo
          nswap=nswap+1
        endif
      enddo
      if(nswap.ne.0) goto 110
* show temporary superlevels
      do j=1,tnslev
        print*,j,tsion(j),sngl(tsg(j)),sngl(tse(j)),sngl(tsq(j)),
     &  trim(tsst(j))
      enddo

      do j=1,maxslev
        sid(j)=' '
      enddo
      j=1
      ii(1)=1
      ii(2)=0
      ii(3)=0
      maxE=tse(1)+DE
      sion(j)=tsion(1)
      write(sid(j),30) sion(j),ii(sion(j))
      do i=1,tnslev
* don't mix ionization stages
        if (tse(i).le.maxE.and.tsion(i).eq.sion(j)) then
          do l=1,nlev
            if (tns(l).eq.i) then
              ns(l)=j
              write(id(l),30) sion(j),ii(sion(j))
              iscan=index(id(l),st(l))
              if (iscan.eq.0) then
                id(l)=trim(id(l))//trim(st(l))
              endif
            endif
          enddo
        else
* start next superlevel
          j=j+1
          if (tsion(i).eq.2) then
* increase energy step progressively from input DE to 10 times that value.
            maxE=tse(i)+DE*(1.+9.*(tse(i)-eion(1))/(eion(2)-eion(1)))
          endif
          sion(j)=tsion(i)
          ii(sion(j))=ii(sion(j))+1
* id of superlevel
          write(sid(j),30) sion(j),ii(sion(j))
30        format('Super_',i1,'_',i3.3)
          do l=1,nlev
            if (tns(l).eq.i) then
              ns(l)=j
* rename original level to ensure redistribution in MULTI
              write(id(l),30) sion(j),ii(sion(j))
              iscan=index(id(l),st(l))
              if (iscan.eq.0) then
                id(l)=trim(id(l))//trim(st(l))
              endif
            endif
          enddo
        endif
      enddo
      nslev=j
* now we have :
      print*,' created ',nslev,' superlevels'
      print*,ii(1),' ',trim(elt),'I   ',ii(2),' ',trim(elt),'II   ',
     & ii(3),' ',trim(elt),'III'
* and each original level i belongs to superlevel j=ns(i)
      do j=1,nslev
* compute superlevel partition function, multiplicity and mean energy
        sq(j)=0.0
        sg(j)=0.0
        se(j)=0.0
        sst(j)=''
        do i=1,nlev
          if (ns(i).eq.j) then
            sq(j)=sq(j)+g(i)*exp(-e(i)/kbcm/temp)
            sg(j)=sg(j)+g(i)
            se(j)=se(j)+e(i)*g(i)*exp(-e(i)/kbcm/temp)
*           concatenate individual spectral term to the super id
            l=index(sid(j),trim(st(i)))
            if (l.eq.0) then
              sid(j)=trim(sid(j))//trim(st(i))
            endif
          endif
        enddo
        se(j)=se(j)/sq(j)
      enddo
* show superlevels
*      do j=1,nslev
*        print*,j,sion(j),sngl(g(j)),sngl(se(j)),sngl(sq(j)),trim(sid(j))
*      enddo

      gsum=0.
      do i=1,nlev
        gsum=gsum+g(i)
      enddo
      print*,' gsum for levels ',gsum
      gsum=0.
      do i=1,nslev
        gsum=gsum+sg(i)
      enddo
      print*,' gsum for superlevels ',gsum

* Now the radiative b-b transition
      do i=1,nslev
        do j=1,nslev
          sf(j,i)=0.
          sq0(j,i)=0.
          sqmax(j,i)=0.
          snq(j,i)=0
          sga(j,i)=0.
          sgv(j,i)=0.
          sgs(j,i)=0.
          slamv(j,i)=0.
        enddo
      enddo
* lines header
      nhead=nhead+1
      read(10,10) head(nhead)
      nhead=nhead+1
      read(10,10) head(nhead)
      nread=nread+2
* read lines
      do l=1,nline   
        read(10,*,iostat=ios) up(l),low(l),f(l),nq(l),qmax(l),q0(l),
     &     iw(l),ga(l),gv(l),gs(l),lam(l),kr(l),lamv(l),iup(l),ilow(l)
* find upper and lower superlevels
        ups(l)=ns(up(l))
        lows(l)=ns(low(l))
        if (ups(l).le.lows(l)) then
* drop this line
          write(40,40) up(l),low(l),ups(l),lam(l),f(l)
40        format('line dropped ',i4,1x,i4,1x,i3,2x,f13.3,1x,1pe9.3,0p)
        endif
      enddo
      nread=nread+nline

* create superlines
* (it would be better to sort the lines before, to avoid reading the full list over and over again)
      nsline=0
      do i=1,nslev
        do j=1,nslev
          if (j.ne.i) then
            sum1=0.
            sum2=0.
            sigmacross=0.
            velexp=0.
            do l=1,nline
              if (ups(l).eq.j.and.lows(l).eq.i) then
                fact1=g(low(l))*exp(-e(low(l))/kbcm/temp)
                fact2=g(low(l))*f(l)
                sum1=sum1+fact1
                sum2=sum2+fact2
         
* f-value is weighted using superlevel internal partition function 
* cf: "3D superlevel NLTE radiative transfer for molecules, PhD, Alexander Berkner,
* 2015, Hamburg

                sf(j,i)=sf(j,i)+f(l)*fact1
                sga(j,i)=sga(j,i)+fact2*ga(l)
                sgs(j,i)=sgs(j,i)+fact2*gs(l)
* check behavior of collisional damping
*                write(50,*) j,i,gv(l),fact2
*end check

* This allows to scrutinize the range of values for sigmacross and velexp.
* For Fe I + Fe II from VALD/Kurucz, I find:
* 0.10<velexp<0.48  and 150<sigmacross<3127
c                if (gv(l).gt.20.) then
c                  write(60,*) int(gv(l)),gv(l)-int(gv(l))
c                endif
                if (gv(l).lt.20.) then
                  if (gv(l).gt.0.) then
* Unsoeld recipe => create a Kurucz-like loggamma6 at 10000K
* convert energy from cm-1 to eV
                    alogc6=log10(ion(low(l))**2 *
     &               ( 1./(1.23981d-4*(eion(ion(up(l)))-e(up(l))))**2 -
     &               1./(1.23981d-4*(eion(ion(low(l)))-e(low(l))))**2) )
     &               - 29.7278
                    gam6 = 8.6735 - 0.3*LOG10(5040./10000.) + 
     &                     log10(boltz*5040.) +
     &                     .4*alogc6
* gv(l) contains a fudge factor
                    gam6 = gam6 + 8.0 + log10(gv(l))
                    print*,'Unsoeld ',gv(l),gam6
                    gv(l)=gam6
                  endif
* transform Kurucz log(gamma6(10000K)) or Unsoeld approx into an ABO-like cross-section+exponent, 
* using the typical temperature provided in input
                  call tune_gam6(gv(l),tunedgv,t)
cc                  print*,'tuned ',gv(l),tunedgv
                else
                  tunedgv=gv(l)
                endif
                
                sigmacross=sigmacross+int(tunedgv)*fact2
                velexp=velexp+(tunedgv-int(tunedgv))*fact2
                
                sqmax(j,i)=max(sqmax(j,i),qmax(l))
                snq(j,i)=max(snq(j,i),nq(l))
                sq0(j,i)=max(sq0(j,i),q0(l))
* gf-value weighted line position
                slamv(j,i)=slamv(j,i)+fact2*lamv(l)

                if (iw(l).ne.0) then
                  stop 'no recipe for IW !!'
                endif
              endif
            enddo
            if (sum2.ne.0.) then
* check behavior of collisional damping
*              write(50,*) j,i,sum2
*              write(50,*)
*end check
              sgv(j,i)=int(sigmacross/sum2)+velexp/sum2
              sf(j,i)=sf(j,i)/sum1
              sga(j,i)=sga(j,i)/sum2
              sgs(j,i)=sgs(j,i)/sum2
              slamv(j,i)=slamv(j,i)/sum2
              if (i.lt.j) then
* we make sure that we have a positive wavelength for the supertransition
                nsline=nsline+1
              endif
            endif
          endif
        enddo
      enddo

* Now the photoionization

* lines header
      nhead=nhead+1
* nhead=4
      read(10,10) head(nhead)
      nhead=nhead+1
      read(10,10) head(nhead)
* read data
      do l=1,ncont
        read(10,*) upc(l),lowc(l),cf(l),nc(l),lambdaminc(l)
c        print*,l, upc(l),lowc(l),cf(l),nc(l),lambdaminc(l)
        if (nc(l).gt.maxcpoint) then
          print*,nc(l),' continuum points, larger than maxcpoint'
          stop 'STOP error; increase maxcpoint.'
        endif
        if (int(lambdaminc(l)).lt.0) then
          read(10,*) (cl(j,l),cx(j,l),j=1,nc(l))
* check:
                  do j=2,nc(l)
                    if (cl(j,l).ge.cl(j-1,l)) then
                      print*,'WARNING input increasing wavel ',j,l
          print*,cl(j-1,l),cl(j,l)
                    endif
                  enddo
        endif 
      enddo
      print*,'read ',ncont,' BF radiative transitions'
      nscont=0
      do i=1,nslev
        do j=1,nslev
          if (j.ne.i) then
            sum1=0.
            sl=0
            k=0
            do l=1,ncont
* find upper and lower superlevels
              ups(l)=ns(upc(l))
              lows(l)=ns(lowc(l))
              if (ups(l).eq.j.and.lows(l).eq.i) then
                k=k+1
                sl(k)=l
cc                print*,'bf ',j,i,upc(l),lowc(l)
cc                print*,'bf ',cf(l),nc(l),lambdaminc(l)
              endif
            enddo
            if (k.gt.0) then 
* we have data for this super bf transition
              nscont=nscont+1
              supc(nscont)=j
              slowc(nscont)=i
            endif
            maxk=k
* now interpolate and add
            if (maxk.eq.1) then
              l=sl(maxk)
              fact1=1.
              sum1=1.
* we just copy the data. No interpolation or addition necessary.
              slambdaminc(nscont)=lambdaminc(l)
cc          print*,'check ',j,i,nscont,slambdaminc(nscont)
              scf(nscont)=cf(l)
              snc(nscont)=nc(l)
              if (lambdaminc(l).lt.0.) then
                do mm=1,nc(l)
                  scl(mm,nscont)=cl(mm,l)
                  scx(mm,nscont)=cx(mm,l)
                enddo
              endif
            else if (maxk.gt.1) then
* first add the detailed cross-sections
* bf rate is weighted using superlevel internal partition function
* cf: "3D superlevel NLTE radiative transfer for molecules, PhD, Alexander Berkner,
* 2015, Hamburg
              first1=.true.
              first2=.true.
              nd=0
              do k=1,maxk
                l=sl(k)
                if (lambdaminc(l).lt.0.) then
                  fact1=g(lowc(l))*exp(-e(lowc(l))/kbcm/temp)
                  sum1=sum1+fact1
                  if (first1) then
* no interpolation necessary
                    nd=nd+1
                    nwav=nc(l)
                    do mm=1,nwav
                      first1=.false.
                      scx(mm,nscont)=cx(mm,l)*fact1
                      scl(mm,nscont)=cl(mm,l)
                    enddo
                  else
* interpolate, use all wavelengths
* temporary store
                    nd=nd+1
                    do mm=1,nwav
                      scltemp(mm)=scl(mm,nscont)
                      scxtemp(mm)=scx(mm,nscont)
                    enddo
                    mm=1
                    kk=1
                    jj=1
* mm : index for already accumulated data [1:nwav]
* kk : index for data to accumulate [1:nc(l)]
* jj : index for accumulation

                    debug=.false.
                    if (j.eq.136.and.i.eq.12) debug=.true.

                    if (scltemp(1).gt.cl(1,l)) then
* we are above the kk edge, we keep the mm data as is.
                      do while (scltemp(mm).gt.cl(1,l).and.
     &                          mm.le.nwav)
                        scl(jj,nscont)=scltemp(mm)
                        scx(jj,nscont)=scxtemp(mm)
                        jj=jj+1
                        mm=mm+1
                      enddo
                    else if (scltemp(1).lt.cl(1,l)) then
* we are above the mm edge, we add the kk data 
                      do while (cl(kk,l).gt.scltemp(1).and.
     &                          kk.le.nc(l))
                          scl(jj,nscont)=cl(kk,l)
                          scx(jj,nscont)=cx(kk,l)*fact1
                          jj=jj+1
                          kk=kk+1
                      enddo
                    endif
* now we have both
* simple case with 2 identical wavelengths
                    do while (kk.le.nc(l).or.mm.le.nwav)
                      if (kk.le.nc(l).and.mm.le.nwav) then
                        if (cl(kk,l).eq.scltemp(mm)) then
                          scl(jj,nscont)=scltemp(mm)
                          scx(jj,nscont)=cx(kk,l)*fact1+scxtemp(mm) 
        if (debug) print*,'1 ',jj,kk,mm,cl(kk,l),scltemp(mm)
                          jj=jj+1
                          kk=kk+1
                          mm=mm+1
                        else if (cl(kk,l).lt.scltemp(mm)) then
                          scl(jj,nscont)=scltemp(mm)
* interpolate kk onto the mm wavelength; the max is to avoid crazy extrapolation
* after last point (nwav)
                          scx(jj,nscont)=scxtemp(mm)+ 
     &                     max((cx(kk-1,l)+ (scltemp(mm)-cl(kk-1,l))*
     &                      (cx(kk,l)-cx(kk-1,l))/
     &                         (cl(kk,l)-cl(kk-1,l)))*fact1,0.)
        if (debug) print*,'2 ',jj,kk,mm,cl(kk,l),scltemp(mm)
                          jj=jj+1
                          mm=mm+1
                        else if (cl(kk,l).gt.scltemp(mm)) then
* interpolate mm onto kk wavelength; the max is to avoid crazy extrapolation
* after last point (nc(l))
                          scl(jj,nscont)=cl(kk,l)
                          scx(jj,nscont)=fact1*cx(kk,l) +
     &                     max(scxtemp(mm-1) + 
     &                         (cl(kk,l)-scltemp(mm-1))*
     &                          (scxtemp(mm)-scxtemp(mm-1))/
     &                            (scltemp(mm)-scltemp(mm-1)),0.)
        if (debug) print*,'3 ',jj,kk,mm,cl(kk,l),scltemp(mm)
                          jj=jj+1
                          kk=kk+1
                        endif
                      else if (kk.gt.nc(l).and.mm.le.nwav) then
* write remaining data for mm, if necessary
                        scl(jj,nscont)=scltemp(mm)
                        scx(jj,nscont)=scxtemp(mm)
        if (debug) print*,'4 ',jj,kk,mm,cl(kk,l),scltemp(mm)
                        jj=jj+1
                        mm=mm+1
                      else if (mm.gt.nwav.and.kk.le.nc(l)) then
* write remaining data for kk, if necessary
                        scl(jj,nscont)=cl(kk,l)
                        scx(jj,nscont)=fact1*cx(kk,l)
        if (debug) print*,'5 ',jj,kk,mm,cl(kk,l),scltemp(mm)
                        jj=jj+1
                        kk=kk+1
                      endif
                    enddo
* update nwav value
                    nwav=jj-1
                  endif
                  slambdaminc(nscont)=-1.
* check:
                  do jj=2,nwav
                    if (scl(jj,nscont).ge.scl(jj-1,nscont)) then
                      print*,'WARNING increasing wavel ',j,i
          print*,scl(jj-1,nscont),scl(jj,nscont)
                    endif
                  enddo
                endif
              enddo
* temporary store, smooth and resample, take every nd point
              do jj=1,nwav
                scxtemp(jj)=scx(jj,nscont)
                scltemp(jj)=scl(jj,nscont)
              enddo
              jj=1
              nd=max(nd,1)
              do mm=1,nwav,nd
                scl(jj,nscont)=scltemp(mm)
                scx(jj,nscont)=scxtemp(mm)
                jj=jj+1
              enddo
              nwav=jj-1
              snc(nscont)=nwav

* now add the Kramers approximation data
              do k=1,maxk
                l=sl(k)
                if (lambdaminc(l).gt.0.) then
                  fact1=g(lowc(l))*exp(-e(lowc(l))/kbcm/temp)
                  sum1=sum1+fact1
                  if (first1.and.first2) then
* nothing yet. just take this one
                    slambdaminc(nscont)=lambdaminc(l)
                    scf(nscont)=cf(l)*fact1
cc                  print*,'check cf ',cf(l),fact1
                    snc(nscont)=nc(l)
                    lambda0=1.d8/(e(upc(l))-e(lowc(l)))
                    do mm=1,snc(nscont)
                      scl(mm,nscont)=lambda0-(mm-1)*
     &                   (lambda0-slambdaminc(nscont))/
     &                    float(snc(nscont)-1)
                      scx(mm,nscont)=scf(nscont)*fact1*
     &                                 (scl(mm,nscont)/lambda0)**3
                    enddo
                    first2=.false.
                  else if (first1.and..not.first2) then
                    lambda0=1.d8/(e(upc(l))-e(lowc(l)))
                    shift=0
                    if (lambda0.gt.scl(1,nscont)) then
                      shift=2
                      do mm=snc(nscont),1,-1
                        scl(mm+shift,nscont)=scl(mm,nscont)
                        scx(mm+shift,nscont)=scx(mm,nscont)
                      enddo
                      do mm=1,shift
                        scl(mm,nscont)=lambda0-(mm-1)*
     &                  (lambda0-scl(shift+1,nscont))/float(shift)
                        scx(mm,nscont)=cf(l)*fact1*
     &                               (scl(mm,nscont)/lambda0)**3
                      scf(nscont)=scf(nscont)+cf(l)*fact1
                      enddo
                      snc(nscont)=snc(nscont)+shift
                      slambdaminc(nscont)=-1.
                    endif
* we suppose that the lambdaminc are close enough. 
* we stop at the last wavelength without checking if we should 
* extend to shorter wavelength
                    do mm=1+shift,snc(nscont)
                      scx(mm,nscont)=scx(mm,nscont)+cf(l)*fact1*
     &                               (scl(mm,nscont)/lambda0)**3
                    enddo
                  else if (.not.first1) then
                    do mm=1,nwav
* add at all positions below photoionization edge
                      lambda0=1.d8/(e(upc(l))-e(lowc(l)))
                      if (scl(mm,nscont).le.lambda0) then
                        scx(mm,nscont)=scx(mm,nscont)+cf(l)*fact1*
     &                                 (scl(mm,nscont)/lambda0)**3
                      endif
                    enddo
                  endif
                endif
              enddo
* renormalize
              if (slambdaminc(nscont).lt.0.) then
                do mm=1,snc(nscont)
                  scx(mm,nscont)=scx(mm,nscont)/sum1
                enddo
              endif
              scf(nscont)=scf(nscont)/sum1
            endif
          endif
        enddo
      enddo

* WRITE UP
* write the superlevels

*********************
* The case for FIXED transition should be added to this program.
      print*,'WARNING ! NSFIX IS NOT DEFINED YET!'
* provide dummy value
      nsfix=0
*********************

      write(20,*) nslev,nsline,nscont,nsfix
      write(20,10) trim(head(1))
      do i=1,nslev
        write(20,20) se(i),sg(i),sid(i),sion(i),i
*20      format(f10.3,1x,f5.0,1x,'''',a50,'''',1x,i1,1x,i4)
20      format(f10.3,1x,f5.0,1x,'''',a150,'''',1x,i1,1x,i4)
      enddo

* Write radiative superlines

      write(20,10) trim(head(2))
* instead of head(3)
      write(20,12) 
12    format('*  J    I     F       NQ   QMAX   Q0  IW     GA       GVW',
     &    '      GS        LAMBDA[AA]    KR    gf-weighted-LBD')
      nwr=0
      do i=1,nslev
        do j=1,nslev
          if (slamv(j,i).ne.0.) then
            if (j.gt.i) then
              nwr=nwr+1
              write(20,1130) j,i,sf(j,i),snq(j,i),sqmax(j,i),sq0(j,i),
     &                     0,sga(j,i),sgv(j,i),sgs(j,i),
     &                     1.d8/(se(j)-se(i)),nwr,slamv(j,i)
1130          format(2I5,1x,1pe10.3,0p,i5,1x,f8.1,1x,f6.2,i2,1x,1pe10.3,
     &            0p,1x,f8.3,1x,1pe10.3,0p,1x,f13.3,1x,i6,2x,f13.3)
            else
* negative lambda
              print*,'superline dropped: ',i,j,sngl(1.d8/(se(j)-se(i)))
            endif
          endif
        enddo
      enddo
      if (nwr.ne.nsline) then
        print*,'PROBLEM ! ,nsline not equal to nwr ',nsline,nwr
      endif
*********
* Write the bf radiative transitions
      write(20,10) trim(head(4))
      write(20,10) trim(head(5))
      do l=1,nscont
        write(20,21) supc(l),slowc(l),scf(l),snc(l),slambdaminc(l)
21      format(1x,i4,1x,i4,2x,ES9.2,1x,i4,2x,f9.0)
        if (slambdaminc(l).lt.0.) then
          write(20,22) (scl(mm,l),scx(mm,l),mm=1,snc(l))
22        format(4(f10.3,es11.3,1x))
        endif
      enddo

*********
* Now the collisions
      nhead=nhead+1
* nhead=6
      read(10,10) head(nhead)
      write(20,10) trim(head(nhead))
      nhead=nhead+1
      read(10,10) head(nhead)
      if (head(nhead).ne.'GENCOL') then
        print*,head(nhead),' not equal to GENCOL'
        stop 'problem'
      else 
        write(20,10) trim(head(nhead))
      endif

      ntr=1
      col=0.
      first=.true.
* number of temperature sets for a given batch
      ntemp=0
      exist=.false.

      do while (.true.) 
        read(10,10,end=99) oneline
        aa=oneline(1:5)
        if (oneline(1:1).eq.'*'.or.oneline(1:3).eq.'END') then
          first3=.true.
* new kind of data or end of file
          print*,'Handling ',trim(oneline)
          if (first) then
* first pass, no data read yet. Write only header
            write(20,10) trim(oneline)
            first=.false.
          else
* define a single set of temperatures for this batch, if needed.
* could be better if based on some kind of average of the input T-set
            if (ntemp.gt.1) then
              nt=10
              do l=1,nt
                tt(l)=l*1000.
              enddo
            else if (ntemp.eq.1) then
              nt=ntr
              do l=1,nt
                tt(l)=tr(l)
              enddo
            else if (ntemp.eq.0) then
              nt=1
            endif
* write up previous batch
            if (nt.gt.1) then
              write(20,15)
              write(20,14) nt,(tt(l),l=1,nt)
14            format(i3,20(1x,f8.0))
15            format('TEMP')
            endif
* compute superlevels partition function for all temperatures
* beware: the partition function is calculated independently
* of the existence of any collisional cross-section data. If 
* there is missing data, the averaged superlevel value might
* be artificially lowered.
            do j=1,nslev
              do l=1,nt
                sqq(l,j)=0.0
                do i=1,nlev
                  if (ns(i).eq.j) then
                    sqq(l,j)=sqq(l,j)+g(i)*exp(-e(i)/kbcm/tt(l))
                  endif
                enddo
              enddo
            enddo
* compute collisional coefficients between superlevels
            scol=0.0
            do i=1,nlev
              do j=1,nlev
                if (j.ne.i) then
                  if (exist(j,i)) then
* first interpolate to a common set of temperatures, if needed
                    if (ntemp.gt.1) then
                      extrapo=.true.
                      first4=.false.
* will extrapolate without telling
                      call spline(nn(j,i),nt,tem(1,j,i),tt,col(1,j,i),
     &                          coll,extrapo,first4)
                    else
                      do l=1,nt
                        coll(l)=col(l,j,i)
                      enddo
                    endif
                    do l=1,nt
                      scol(l,ns(j),ns(i))=scol(l,ns(j),ns(i))+coll(l)*
     &                   g(min(i,j))*exp(-e(min(i,j))/kbcm/tt(l))/
     &                   sqq(l,min(ns(j),ns(i)))
                    enddo
                  endif
                endif
              enddo
            enddo
* write collisions on super-atom file
            do i=1,nslev
              do j=1,nslev
                if ((down.and.j.gt.i.and.scol(1,j,i).gt.0.).or.
     &              (.not.down.and.j.lt.i.and.scol(1,j,i).gt.0.)) then
                  write(20,10) trim(type)
                  write(20,16) j,i,(scol(l,j,i),l=1,nt)
16                format(2(i5),20(1x,1pe10.3),0p)
                endif
              enddo
            enddo
            ntr=1
            col=0.0
            ntemp=0
            exist=.false.
* write header for next batch
            write(20,10) trim(oneline)
          endif
        else
* read a temperature set
          if (oneline(1:4).eq.'TEMP'.or.oneline(1:4).eq.'temp') then
            ntemp=ntemp+1
            read(10,*) ntr,(tr(l),l=1,ntr)
            if (ntr.gt.20) then
              stop 'increase nt dimension'
            endif
          else if (aa.eq.'UPS_E'.or.aa.eq.'CI'.or.aa.eq.'CH_CE'
     &             .or.aa.eq.'OHM'.or.aa.eq.'CH'.or.aa.eq.'CHI') then
* read data for this batch

* SHOULD CHECK IF TYPE IS SAME OR NOT AS PREVIOUS !!!!!!!!
* IF CHANGE OF TYPE : combine data first for superline, before reading next batch

            type=aa
            read(10,*) j,i,(col(l,j,i),l=1,ntr)
            exist(j,i)=.true.
* affect temperature to this set of data
            nn(j,i)=ntr
            do l=1,ntr
              tem(l,j,i)=tr(l)
            enddo
* upward or downward rate
            if (first3) then
              if (j.gt.i) then
                down=.true.
              else
                down=.false.
              endif
              first3=.false.
            endif
          else
            print*,trim(oneline)
            stop 'PROBLEM, should be ups_e or similar?'
          endif
        endif
      enddo

* reached end of file
99    continue


* WRITE A FULL ATOM WITH RENAMED LEVELS AND THE FULL SET OF
* B-B and B-F transitions
* NO NEED FOR COLLISIONS IN THAT ONE.
      write(30,*) nlev,nline,ncont,nfix
      write(30,10) trim(head(1))
      do i=1,nlev
        write(30,20) e(i),g(i),id(i),ion(i),i
      enddo
      write(30,10) trim(head(2))
      write(30,10) trim(head(3))
      do l=1,nline
        strength=log10(f(l)*g(low(l))*lamv(l))-e(low(l))/8065.*5040./t
        write(30,1131) up(l),low(l),f(l),nq(l),qmax(l),q0(l),iw(l),
     &                 ga(l),
     &             gv(l),gs(l),lam(l),kr(l),lamv(l),iup(l),ilow(l),
     &   strength

1131    format(2I5,1x,1pe10.3,0p,i5,1x,f8.1,1x,f6.2,i2,1x,1pe10.3,
     &         0p,1x,f8.3,1x,1pe10.3,0p,1x,f13.3,1x,i6,2x,f13.3,
     &         1x,'''',a1,'''',1x,'''',a1,'''',1x,f7.3)
      enddo
      rewind(10)
      do i=1,nread
        read(10,*)
      enddo
      read(10,10) oneline
      do while (oneline(1:1).eq.'*')
        write(30,10) trim(oneline)
        read(10,10) oneline
      enddo
      do i=1,ncont
        write(30,10) trim(oneline)
        read(oneline,*) idum,idum,dum,mm,lambdaminc(1)
        if (lambdaminc(1).lt.0.) then
          m=int(mm/4)
          if (mm-4*m.gt.0) then 
            m=m+1
          endif
          do j=1,m
            read(10,10) oneline
            write(30,10) trim(oneline)
          enddo
        endif
        read(10,10) oneline
      enddo
      write(30,31)
      write(30,32)
31    format('GENCOL')
32    format('END')

      print*,'Normal end'
      stop
      end
************************************************************************
*
      subroutine tune_gam6(gv,tunedgv,temp)
* transforms Kurucz gamma6 into an ABO-like broadening parameter
* assuming a velocity exponent=0.3
* the value of this exponent for ABO calculation in VALD FeI/FeII
* lies between 0.10 and 0.48 (43986 lines)
*
      implicit none
      real temp,gv,tunedgv,gam6,sigma,sigmacross,
     &     relvel,constb,fyrapi,velexp,gammln,mh,ma,c,h,
     &     boltz,gam6anstee,redmas,x,beta

      boltz=1.3806e-16
      c=2.9979e10
      mh=1./6.023e23
      ma=55.845/6.023e23
      h=6.6261e-27

      FYRAPI = 16.*ATAN(1.)
      redmas=1./((1./MH)+(1./MA))
      constb=8.*boltz*4.0/fyrapi/redmas

      if (gv.lt.0.) then
* Kurucz recipe
        gam6= 10.**gv*(temp/10000.)**0.3
        velexp=0.30
        beta=exp(gammln(2.-velexp/2.)) *2. *(16./fyrapi)**(velexp/2.)
        relvel=sqrt(constb*temp)
        sigma=gam6/beta/relvel*(relvel/1.e6)**velexp
        sigmacross=int(sigma/2.8002e-17)
        tunedgv=sigmacross+velexp
      else if (gv.lt.20.) then
* fdamp = fudge factor for Unsoeld recipe

*  THIS SHOULD BE CHANGED (implement recipe?) Only 3 lines.... BPz 24/03-2016
        print*,' tunegv WARNING : Unsoeld recipe not implemented'
        tunedgv=gv
      endif

* ABO recipe
c      sigma=sigmacross*2.8002e-17
c      gam6anstee=2.*(16./fyrapi)**(velexp/2.)*
c     &                exp(gammln(2.-velexp/2.))*
c     &                relvel*sigma*(relvel/1.e6)**(-velexp)


      return
      end
**********************************************************************************
      FUNCTION gammln(xx)
* returns ln gamma(xx) The Gamma function, Numerical recipes, 2nd ed, p 206
      implicit none
      REAL gammln,xx
      INTEGER j
      DOUBLE PRECISION ser,stp,tmp,x,y,cof(6)
      SAVE cof,stp
      DATA cof,stp/76.18009172947146d0,-86.50532032941677d0,
     *24.01409824083091d0,-1.231739572450155d0,.1208650973866179d-2,
     *-.5395239384953d-5,2.5066282746310005d0/
      x=xx
      y=x
      tmp=x+5.5d0
      tmp=(x+0.5d0)*log(tmp)-tmp
      ser=1.000000000190015d0
      do 11 j=1,6
        y=y+1.d0
        ser=ser+cof(j)/y
11    continue
      gammln=tmp+log(stp*ser/x)
      return
      END
C  (C) Copr. 1986-92 Numerical Recipes Software 1"n26@1kN.
* see link ~/smallcalc/Numerical.recipes
*

*******************************************************************************
      SUBROUTINE SPLINE (N, nout, X, xout, Y, yout,extrapo,first)               00002230
      implicit none
      INTEGER N, nout                                                   00002240
      REAL X(N), Y(N), B(N), C(N), D(N), xout(nout), yout(nout)         00002250
      INTEGER I, J, K                                                   00003490
      REAL DX                                                           00003500
C                                                                       00002260
C  THE COEFFICIENTS B(I), C(I), AND D(I), I=1,2,...,N ARE COMPUTED      00002270
C  FOR A CUBIC INTERPOLATING SPLINE                                     00002280
C                                                                       00002290
C    S(X) = Y(I) + B(I)*(X-X(I)) + C(I)*(X-X(I))**2 + D(I)*(X-X(I))**3  00002300
C                                                                       00002310
C    FOR  X(I) .LE. X .LE. X(I+1)                                       00002320
C                                                                       00002330
C  INPUT..                                                              00002340
C                                                                       00002350
C    N = THE NUMBER OF DATA POINTS OR KNOTS (N.GE.2)                    00002360
C    X = THE ABSCISSAS OF THE KNOTS IN STRICTLY INCREASING ORDER        00002370
C    Y = THE ORDINATES OF THE KNOTS                                     00002380
C                                                                       00002390
C  OUTPUT..                                                             00002400
C                                                                       00002410
C    B, C, D  = ARRAYS OF SPLINE COEFFICIENTS AS DEFINED ABOVE.         00002420
C                                                                       00002430
C  USING  P  TO DENOTE DIFFERENTIATION,                                 00002440
C                                                                       00002450
C    Y(I) = S(X(I))                                                     00002460
C    B(I) = SP(X(I))                                                    00002470
C    C(I) = SPP(X(I))/2                                                 00002480
C    D(I) = SPPP(X(I))/6  (DERIVATIVE FROM THE RIGHT)                   00002490
C                                                                       00002500
C  THE ACCOMPANYING FUNCTION SUBPROGRAM  SEVAL  CAN BE USED             00002510
C  TO EVALUATE THE SPLINE.                                              00002520
C                                                                       00002530
C                                                                       00002540
      INTEGER NM1, IB,jj,iout                                                   00002550
      REAL T,u                                                            00002560
      logical extrapo,first
ccc      data extrapo/.false./
      data jj/1/
C                                                                       00002570
      NM1 = N-1                                                         00002580
      IF ( N .LT. 2 ) then 
        print*, 'cannot interpolate with less than 2 points!!'
        print*,' spline stop!'
        stop
      endif
      IF ( N .ge. 3 ) then                                              00002600
C                                                                       00002610
C  SET UP TRIDIAGONAL SYSTEM                                            00002620
C                                                                       00002630
C  B = DIAGONAL, D = OFFDIAGONAL, C = RIGHT HAND SIDE.                  00002640
C                                                                       00002650
      D(1) = X(2) - X(1)                                                00002660
      C(2) = (Y(2) - Y(1))/D(1)                                         00002670
      DO 10 I = 2, NM1                                                  00002680
         D(I) = X(I+1) - X(I)                                           00002690
         B(I) = 2.*(D(I-1) + D(I))                                      00002700
         C(I+1) = (Y(I+1) - Y(I))/D(I)                                  00002710
         C(I) = C(I+1) - C(I)                                           00002720
   10 CONTINUE                                                          00002730
C                                                                       00002740
C  END CONDITIONS.  THIRD DERIVATIVES AT  X(1)  AND  X(N)               00002750
C  OBTAINED FROM DIVIDED DIFFERENCES                                    00002760
C                                                                       00002770
      B(1) = -D(1)                                                      00002780
      B(N) = -D(N-1)                                                    00002790
      C(1) = 0.                                                         00002800
      C(N) = 0.                                                         00002810
      IF ( N .EQ. 3 ) GO TO 15                                          00002820
      C(1) = C(3)/(X(4)-X(2)) - C(2)/(X(3)-X(1))                        00002830
      C(N) = C(N-1)/(X(N)-X(N-2)) - C(N-2)/(X(N-1)-X(N-3))              00002840
      C(1) = C(1)*D(1)*D(1)/(X(4)-X(1))                                 00002850
      C(N) = -C(N)*D(N-1)*D(N-1)/(X(N)-X(N-3))                          00002860
C                                                                       00002870
C  FORWARD ELIMINATION                                                  00002880
C                                                                       00002890
   15 DO 20 I = 2, N                                                    00002900
         T = D(I-1)/B(I-1)                                              00002910
         B(I) = B(I) - T*D(I-1)                                         00002920
         C(I) = C(I) - T*C(I-1)                                         00002930
   20 CONTINUE                                                          00002940
C                                                                       00002950
C  BACK SUBSTITUTION                                                    00002960
C                                                                       00002970
      C(N) = C(N)/B(N)                                                  00002980
      DO 30 IB = 1, NM1                                                 00002990
         I = N-IB                                                       00003000
         C(I) = (C(I) - D(I)*C(I+1))/B(I)                               00003010
   30 CONTINUE                                                          00003020
C                                                                       00003030
C  C(I) IS NOW THE SIGMA(I) OF THE TEXT                                 00003040
C                                                                       00003050
C  COMPUTE POLYNOMIAL COEFFICIENTS                                      00003060
C                                                                       00003070
      B(N) = (Y(N) - Y(NM1))/D(NM1) + D(NM1)*(C(NM1) + 2.*C(N))         00003080
      DO 40 I = 1, NM1                                                  00003090
         B(I) = (Y(I+1) - Y(I))/D(I) - D(I)*(C(I+1) + 2.*C(I))          00003100
         D(I) = (C(I+1) - C(I))/D(I)                                    00003110
         C(I) = 3.*C(I)                                                 00003120
   40 CONTINUE                                                          00003130
      C(N) = 3.*C(N)                                                    00003140
      D(N) = D(N-1)                                                     00003150

      else                                                               00003160
C                                                                       00003170
      B(1) = (Y(2)-Y(1))/(X(2)-X(1))                                    00003180
      C(1) = 0.                                                         00003190
      D(1) = 0.                                                         00003200
      B(2) = B(1)                                                       00003210
      C(2) = 0.                                                         00003220
      D(2) = 0.                                                         00003230

      endif 

      do iout=1,nout
        u=xout(iout)

C                                                                       00003290
C  THIS SUBROUTINE EVALUATES THE CUBIC SPLINE FUNCTION                  00003300
C                                                                       00003310
C    SEVAL = Y(I) + B(I)*(U-X(I)) + C(I)*(U-X(I))**2 + D(I)*(U-X(I))**3 00003320
C                                                                       00003330
C    WHERE  X(I) .LT. U .LT. X(I+1), USING HORNER:S RULE                00003340
C                                                                       00003350
C  IF  U .LT. X(1) THEN  I = 1  IS USED.                                00003360
C  IF  U .GE. X(N) THEN  I = N  IS USED.                                00003370
C                                                                       00003380
C  INPUT..                                                              00003390
C                                                                       00003400
C    N = THE NUMBER OF DATA POINTS                                      00003410
C    U = THE ABSCISSA AT WHICH THE SPLINE IS TO BE EVALUATED            00003420
C    X,Y = THE ARRAYS OF DATA ABSCISSAS AND ORDINATES                   00003430
C    B,C,D = ARRAYS OF SPLINE COEFFICIENTS COMPUTED BY SPLINE           00003440
C                                                                       00003450
C  IF  U  IS NOT IN THE SAME INTERVAL AS THE PREVIOUS CALL, THEN A      00003460
C  BINARY SEARCH IS PERFORMED TO DETERMINE THE PROPER INTERVAL.         00003470
C                                                                       00003480
        IF ( jj .GE. N ) jj = 1              
        IF ( U .LT. X(jj) ) GO TO 100
        IF ( U .LE. X(jj+1) ) GO TO 300
C                                       
C  BINARY SEARCH                       
C                                     
  100   jj = 1                         
        J = N+1                       
  200   K = (jj+J)/2                 
        IF ( U .LT. X(K) ) J = K    
        IF ( U .GE. X(K) ) jj = K  
        IF ( J .GT. jj+1 ) GO TO 200
C                                
C  EVALUATE SPLINE              
C                              
  300   DX = U - X(jj)          
        yout(iout) = Y(jj) + DX*(B(jj) + DX*(C(jj) + DX*D(jj)))
cc
        if (extrapo) then
*
* linear extrapolation  / implemented for version 7.3    BPz 12/10-2007
          if (u.gt.x(n)) then
c extrapolate upwards
            yout(iout)=y(n)+(y(n)-y(n-1))/(x(n)-x(n-1))*
     &               (u-x(n))
            if (first) then
              print*,'=============================================='
              print*,'WARNING, spline, outside range !'
              print*,' last tabulated: ',x(n),' wanted : ',u
              print*,'WARNING, spline, extrapolating upwards  !'
              print*,'=============================================='
              first=.false.
            endif
          else if (u.lt.x(1)) then
c extrapolate downwards
            yout(iout)=y(1)+(y(2)-y(1))/(x(2)-x(1))*
     &               (u-x(1))
            if (first) then
              print*,'=============================================='
              print*,'WARNING, spline, outside range !'
              print*,' first tabulated: ',x(1),' wanted : ',u
              print*,'WARNING, spline, extrapolating downwards!'
              print*,'=============================================='
              first=.false.
            endif
          endif
        else
* no extrapolation (we take the last value)
* was the case in version pre-7.3, with last logP6=+1, and last T=1500K .
          if (u.gt.x(n).or.u.lt.x(1)) then
            yout(iout)=y(jj)
            if (first) then
              print*,'=============================================='
              print*,'WARNING, spline, outside opacity table !'
              print*,' tabulated range : ',x(1),x(n),' wanted : ',u
              print*,'WARNING, spline, using the nearest opac value!'
              print*,'=============================================='
              first=.false.
            endif
          endif
        endif
      enddo

      RETURN                                            
      END                                              
